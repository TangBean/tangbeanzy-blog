---
weight: 1
title: "Unity Project 文件类型介绍"
date: 2023-09-02
---

# Unity Project 文件类型介绍

为什么要介绍这个，因为在把本地的 Unity 通过 Git 提交到 Remote 时，开始纠结哪些内容需要被提交到 Remote，然后发现我似乎不太知道 Unity 工程里的改动，都对应着哪些文件的变化，在 git add 的时候不太知道需要将哪些文件 add 进去。所以就有了这篇文章，介绍 Unity Project 中这些文件夹和文件都是用来放什么的、干什么的。

开篇上重点，先给出最初问题的答案，所以最后需要被 push 到 remote 的文件有哪些？

![](https://cdn.tangbeanzy.com/img/20230902_use-git-in-unity-project_fig1.png)

其中 Packages folder 只需要包含 `manifest.json`,`packages-lock.json` 这两个文件即可。
基本上必选文件就这些，其他有一些 optional 的可以根据需要加。

打开一个 Unity 工程，`ll -al`一下，基本就能看见这些文件夹和文件，接下来我们会一一介绍它们。先介绍文件夹部分，再介绍文件部分。

## 文件夹部分
### `Assets/`

- **用途：** 项目中所有游戏资源（脚本、模型、纹理、声音等）的存放地点。这是我们改动最频繁的文件夹，也是游戏的核心内容所在。
- **生命周期：** 一直存在。你的工作就是疯狂往这个文件夹里填游戏内容，它没了你游戏也没了。
- **谁负责管理：** 你自个儿。
- **版本控制：** must be **push to remote** ！！！

这个文件夹是核中核，core 中 core。
你打开这个文件夹，会发现这里面所有的文件夹、文件，都会有一个同名的 `.meta` 文件。就下面这样：

```
folder1/
folder1.meta
file1.txt
file1.meta
```
这个文件是 Unity 给你创建的，是用来存储和这个文件相关的元数据的。一般会与它们所描述的文件或文件夹放在一起，并且它们的名字也会和相应的文件或文件夹名字一样，只是后缀为 `.meta`。
它里面主要放了以下信息：

- **唯一标识符（GUID）：** 每个资源（包括文件和文件夹）在 Unity 中都有一个唯一标识符。这确保了即使你更改了文件或文件夹的名称或位置，引用也不会丢失。
- **类型信息：** .meta 文件指示资源的类型，例如是否为纹理、脚本、预制件（Prefab）等。
- **导入设置：** 对于需要导入设置的资源（例如纹理或模型），.meta 文件也会保存这些设置。
- **其他属性：** 某些类型的资源可能有额外的元数据，这些也会被存储在 .meta 文件中。

因为这个文件很重要，所以有一些 **注意事项**：

- **不要手动编辑或删除 .meta 文件，除非你确切知道自己在做什么。**
- **当你在文件系统中（而不是在 Unity 编辑器中）添加、删除或移动文件时，确保相应的 .meta 文件也被一同处理。**

### `Packages/`

- **用途：** 此文件夹用于存储 Unity Package Manager 管理的所有外部包和库。这可能包括 Unity 提供的标准库和从第三方获取的库。
- **生命周期：** 根据项目需求添加或移除。通常在项目初始化时设置，但后期也可进行修改。
- **谁负责管理：** Unity 自动管理，你不用管，也最好没事别管。
- **版本控制：** **部分 push to remote**。虽然包的具体文件通常不在版本控制之内，但包里这两个文件要被 push to remote：`manifest.json`,`packages-lock.json`。为了确保大家的依赖的包的版本是相同的，作用和 java 里的 maven pom 文件有点类似。

总体来说，manifest.json 主要用于声明依赖，而 packages-lock.json 用于确保这些依赖在所有环境中保持一致。这两个文件共同工作，以简化 Unity 项目的依赖管理。
它们的具体作用如下：

- **Packages/manifest.json**
   - **依赖管理：** 这个文件用于列出 Unity 项目所依赖的所有 Unity Package，包括版本信息。当你通过 Unity 的 Package Manager 添加或删除包时，这个文件会自动更新。
   - **自定义依赖：** 你也可以手动编辑这个文件，以添加来自其他来源（如 Git 存储库）的包。
   - **项目共享：** 当其他开发者需要运行你的项目时，Unity 会参考这个文件自动下载和安装必要的包，确保项目在不同的机器上具有一致的行为。
- **Packages/packages-lock.json**
   - **锁定版本：** 这个文件锁定了项目中使用的每个包的具体版本。这样做的目的是确保在不同的环境和开发机器上，每个包的版本都是一致的。
   - **版本控制：** 这个文件通常也会被添加到版本控制系统中，除非你有明确的理由不这么做。将此文件添加到版本控制系统可以确保团队中的每个成员都使用相同版本的依赖包，从而减少“在我的机器上能运行”这类问题。
   - **自动生成：** 一般情况下，你不需要手动编辑这个文件。当你通过 Package Manager 添加、更新或删除包时，这个文件会自动更新。


### `ProjectSettings/`

- **用途：** 这个文件夹包含项目的全局设置，如质量设置、构建设置、输入设置等。
- **生命周期：** 一直存在。
- **谁负责管理：** Unity 自动管理，你不用管，也最好没事别管。
- **版本控制：** **push to remote**。为了确保所有参与项目开封的人都使用相同的项目设置。


### `Library/`

- **用途：** 用于存储 Unity 编辑器生成的所有中间文件，如预编译的资产和缓存。这是为了提高加载和编译速度。
- **生命周期：** 可以在项目周期的任何时间内生成和删除。
- **谁负责管理：** Unity 自动管理，你不用管，也最好没事别管。
- **版本控制：** No。因为它里面的数据是可以从 Assets/ 和 ProjectSettings/ 重新生成的。通常在项目打开时生成。


### `Logs/`

- **用途：** 存储 Unity 编辑器和运行时的日志文件，根据 Unity 编辑器和应用程序的运行状态生成和更新。
- **生命周期：** 这个文件夹会一直在，但里面的文件会根据 Unity 编辑器和应用程序的运行状态生成和更新。
- **谁负责管理：** Unity 自动管理，你不用管，也最好没事别管。
- **版本控制：** No。日志文件会在每次运行 Unity 编辑器或构建的应用程序时生成或更新。是和游戏功能没什么功能的数据。


### `obj/`

- **用途：** 与 .NET 构建流程相关的临时文件和中间状态通常存放在这里。
- **生命周期：** 与 .NET 构建流程相关的临时文件和中间状态通常存放在这里。
- **谁负责管理：** Unity 自动管理，你不用管，也最好没事别管。
- **版本控制：** No。可以重新生成的中间文件不用加。


### `Temp/`

- **用途：** 存储临时文件，这些文件可能是编译过程中的中间文件、缓存或其他 Unity 需要短暂存储的数据。
- **生命周期：** 这些临时文件会在 Unity 编辑器关闭或者其他相关操作完成后被清除。
- **谁负责管理：** Unity 自动管理，你不用管，也最好没事别管。在某些罕见的情况下，清空 Temp 文件夹（确保 Unity 编辑器已关闭）可能会解决一些问题，但通常这并不是必要的操作。
- **版本控制：** No。


### `UserSettings/`

- **用途：** 用于存储用户级别的设置和配置，这可能包括布局设置、自定义快捷键、插件设置等。
- **生命周期：** 一直存在。关闭 Unity 编辑器也不会消失。
- **谁负责管理：** Unity 自动管理，你不用管，也最好没事别管。
- **版本控制：** No。这是你自己的设置，不用共享给别人。


### `.git`

- **用途：** Git 版本控制需要。
- **生命周期：** 一直存在。
- **版本控制：** No。


### `.idea`

- **用途：** 放一些和 Jetbrains Brain 家 IDE 工程相关的一些东西，每太仔细研究过每个文件是干啥的。
- **生命周期：** 一直存在。
- **谁负责管理：** Rider IDE。
- **版本控制：** No。


### `.plastic`

- **用途：** 在 Unity 工程中通常表示该工程正在使用 Plastic SCM 作为版本控制系统。Plastic SCM 是一个分布式版本控制系统，与 Git 类似，但是设计上有一些不同的方面，并且提供了一些专门针对大型项目和二进制文件（如图像、音频和预编译的资产）的优化。
- **生命周期：** 一直存在。
- **版本控制：** No。

这个文件夹显然不是每个工程都有的，比如我们的工程是用 Git 作为版本控制系统的，那么有 .git 文件夹就可以了，这个文件夹显然是不需要的。所以完全可以删掉，会生成它完全是我在创建项目的时候有一些配置选错了。

## 文件部分

简单总结一下，前面 3 个文件：`YGT-Great-World-Simulator.sln`,`Assembly-CSharp.csproj`,`Assembly-CSharp-Editor.csproj`主要用于 C# 代码编辑和编译。这些文件主要用于与集成开发环境（IDE）如 Visual Studio 或 Rider 等交互，重新生成创建也没啥不可以。

后面两个文件：`.gitignore`,`ignore.conf`主要用于指示哪些文件夹/文件应被版本控制忽略，比如前面被明确标明不需要被加入到版本控制中的文件夹们。它们的区别在于，`.gitignore`是专为 Git 设计的，`ignore.conf`则更为通用，其具体用途和语法取决于它在哪里被使用，所以我们两个都加了。

### `YGT-Great-World-Simulator.sln`（工程名.sln）

- **用途：** 定义了项目的结构和各个项目间的依赖关系，用于组织多个项目文件（如下面的 `.csproj` 文件）。它描述了工程中所有子项目之间的关系和依赖。 
- **IDE 交互：** 当你在 IDE 中打开这个文件时，IDE 会加载整个 Unity 工程的代码，包括运行时和编辑器脚本。 
- **版本控制：** 可选。看是否需要在团队间共享这个配置，我觉得不共享也是可以的。


### `Assembly-CSharp.csproj`

- **用途：** 这个文件描述了 Unity 项目中主要运行时代码的编译设置。这包括哪些 C# 文件需要被编译、引用了哪些库等。 
- **IDE 交互：** 当你在 IDE 中打开 Unity 工程时，这个文件帮助 IDE 理解如何组织和编译你的代码。 
- **版本控制：** 可选。看是否需要在团队间共享这个配置，我觉得不共享也是可以的。


### `Assembly-CSharp-Editor.csproj`

- **用途：** 这个文件与 `Assembly-CSharp.csproj` 类似，但是专门用于 Unity 编辑器脚本。这些脚本通常在 Unity 编辑器中运行，而不是在最终构建的游戏中。 
- **IDE 交互：** 这个文件同样用于帮助 IDE 理解如何组织和编译编辑器特定的代码。 
- **版本控制：** 可选。看是否需要在团队间共享这个配置，我觉得不共享也是可以的。


### `.gitignore`

- **用途：** `.gitignore`文件是用于 Git 版本控制系统的。当你在一个使用 Git 的项目中进行操作（如克隆、提交、推送等）时，Git 会参考`.gitignore`文件来决定哪些文件或目录应当被忽略，即不纳入版本控制。 
- **适用范围：** 仅适用于 Git。 


### `ignore.conf`

- **用途：** `ignore.conf` 文件的用途取决于它在哪个系统或应用中被使用。例如，某些备份软件或自定义应用可能使用 `ignore.conf` 来确定哪些文件应该被忽略。此外，Plastic SCM 这样的其他版本控制系统也可能使用类似 `ignore.conf` 的文件。
- **适用范围：** 可以在不同的应用和系统中使用，不限于版本控制。

